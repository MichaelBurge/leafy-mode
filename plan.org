* Leafy Metadata
:PROPERTIES:
:drawer-name: meta
:input-tokens: 214750
:output-tokens: 35738
:billed-tokens: 250488
:END:

* Project Summary

This project involves using the ChatGPT model from OpenAI to assist with project planning and organization within an org-mode file. The aim is to create a more streamlined workflow by allowing users to interact with the model from within Emacs.

** Functions:

- `leafy-get-section-for-element`: Given an Org mode paragraph element, returns the section element that encloses it.
- `leafy-insert-section-after`: Inserts a new section after the current one with a given title and content.
- `leafy-get-context-at-element`: Given an Org element, returns the immediate context surrounding it.
- `leafy-get-context`: Returns a list of all headings and their titles up to the top-level heading, along with their paragraphs.
- `leafy-do-chatgpt-request`: Processes the response from the ChatGPT model and inserts it into the buffer.
- `get-meta-property` and `set-meta-property`: Stores a property in a global variable in the document.
- `leafy-get-sections`: Extracts every section in the buffer as a (level, drawer, tag, title, content).
- `leafy-get-property-drawer-for-element-section`: Gets the closest section's property drawer(holds tokens, priorities, etc.)
- `leafy-extract-properties`: Converts a property drawer to an alist.
- `leafy-get-priority` and `leafy-set-priority`: Given a property drawer, acts on the priority affecting whether it's included in ChatGPT's context.
- `leafy-count-tokens`: Counts number of tokens in a string.

* todo items
** Immediate items
*** TODO Prepare a context in a temporary buffer that can be copy-pasted to the web UI.
*** TODO Automatically strip out context to fit within the limit.

** Backlog
*** TODO Include current price of project in the status bar.

* Chat

** Project: Better capability for handling large documents.

ChatGPT has a context size of 4096 tokens. It's easy to exceed that limit. Next project is prioritizing what tokens end up in your context. Right now, I have to constantly delete most of the document every time I complete a major feature, and it'd be nice if the document could just grow without bound and our code gracefully handled it.

Implementation strategy:
1. (DONE) Change code so that a list of ("user" message) ("assistant" message) turns are sent instead of the whole document in one string. (Please confirm you can see this)
2. (TODO) Infer a priority for each section: Sibling nodes are highest, then anything with explicit positive priority markers, then everything else.
3. (TODO) Alternatively, we could ask ChatGPT to prioritize sections by choosing what things are irrelevant.
4. (TODO) Remove sections from context using priority.

*** Implementation

Please implement `leafy-drop-one-section`. It's going to use a very simple rule to start.

1. Start at the end of the list and remember the current level.
2. Iterate backwards looking for the first section that increases in level.
3. If level decreases, remember it as the current level.
4. If we reach the beginning without finding a section, then just delete the earliest section.
   
Input is a list of (level, drawer, tag, title, content).
Output is the index of the section to remove.
*** ChatGPT response                                              :assistant:
:PROPERTIES:
:input-tokens: 749
:output-tokens: 282
:billed-tokens: 1031
:END:
Sure, here's an implementation for `leafy-drop-one-section`:

```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```

This function works by looping through the sections from end to beginning and keeping track of the previous level (which starts at -1). For each section, it checks if the indentation level is smaller than the previous level, indicating that we've found a section that increases in indentation. If no such section is found, then the earliest section is returned.

The return value is the index of the section to remove, which can be used to modify the original list using `(delete-at sections index)`.

Let me know if you have any questions or if there's anything else you want me to add!

*** Debug code

This test

```
(ert-deftest test-leafy-drop-one-section ()
  "Test for `leafy-drop-one-section` function."
  (let ((sections '((1 nil nil "Section 1" "Text for section 1.")
                    (2 nil nil "Subsection 1" "Text for subsection 1.")
                    (2 nil nil "Subsection 2" "Text for subsection 2.")
                    (3 nil nil "Subsubsection 1" "Text for subsubsection 1.")
                    (1 nil nil "Section 2" "Text for section 2."))))
    ;; Drop non-keeper
    (let ((result (leafy-drop-one-section sections)))
      (should (equal result 3))
      (should (equal sections
                     '((1 nil nil "Section 1" "Text for section 1.")
                       (2 nil nil "Subsection 1" "Text for subsection 1.")
                       (2 nil nil "Subsection 2" "Text for subsection 2.")
                       (1 nil nil "Section 2" "Text for section 2.")))))))
```

fails with `result` being equal to 4 not 3.

Your task is to debug `leafy-drop-one-section` and locate the problem. To start, produce an execution trace.

*** Spam a bunch of tokens like 1000 parentheses. I want to test the context limiting code.
*** ChatGPT response                                              :assistant:
:PROPERTIES:
:input-tokens: 1242
:output-tokens: 33
:billed-tokens: 1275
:END:
I'm not sure what you're trying to achieve with this request. Could you provide more information about what you're trying to test and how I can help?

* test
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```

```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```

```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```
```emacs-lisp
(cl-defun leafy-drop-one-section (sections)
  "Returns the index to remove of the last section that increases indentation."
  (let ((len (length sections))
        (indentation-level -1))
    (dotimes (i len)
      (let ((j (- len i 1))
            (new-indentation-level 10000))
        (while (and (> j 0) (<= (car (nth j sections)) indentation-level))
          (setq j (- j 1)))
        (setq new-indentation-level (car (nth j sections)))
        (when (> new-indentation-level indentation-level)
          (return-from leafy-drop-one-section j)))
      (setq indentation-level (car (nth i sections))))))
```

** ChatGPT, can you list out all the functions available to use?
** ChatGPT response                                               :assistant:
:PROPERTIES:
:input-tokens: 1279
:output-tokens: 129
:billed-tokens: 1408
:END:
Sure! Here are the functions available for use in this project:

- `leafy-get-section-for-element`
- `leafy-insert-section-after`
- `leafy-get-context-at-element`
- `leafy-get-context`
- `leafy-do-chatgpt-request`
- `get-meta-property` and `set-meta-property`
- `leafy-get-sections`
- `leafy-get-property-drawer-for-element-section`
- `leafy-extract-properties`
- `leafy-get-priority`
- `leafy-set-priority`
- `leafy-count-tokens`
- `leafy-drop-one-section`


