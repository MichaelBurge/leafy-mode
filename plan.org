* Leafy Metadata
:PROPERTIES:
:drawer-name: meta
:input-tokens: 233380
:output-tokens: 38456
:billed-tokens: 271836
:END:

* Project Summary

This project involves using the ChatGPT model from OpenAI to assist with project planning and organization within an org-mode file. The aim is to create a more streamlined workflow by allowing users to interact with the model from within Emacs.

** Functions:

- `leafy-get-section-for-element`: Given an Org mode paragraph element, returns the section element that encloses it.
- `leafy-insert-section-after`: Inserts a new section after the current one with a given title and content.
- `leafy-get-context-at-element`: Given an Org element, returns the immediate context surrounding it.
- `leafy-get-context`: Returns a list of all headings and their titles up to the top-level heading, along with their paragraphs.
- `leafy-do-chatgpt-request`: Processes the response from the ChatGPT model and inserts it into the buffer.
- `get-meta-property` and `set-meta-property`: Stores a property in a global variable in the document.
- `leafy-get-sections`: Extracts every section in the buffer as a (level, drawer, tag, title, content).
- `leafy-get-property-drawer-for-element-section`: Gets the closest section's property drawer(holds tokens, priorities, etc.)
- `leafy-extract-properties`: Converts a property drawer to an alist.
- `leafy-get-priority` and `leafy-set-priority`: Given a property drawer, acts on the priority affecting whether it's included in ChatGPT's context.
- `leafy-count-tokens`: Counts number of tokens in a string.

* todo items
** Immediate items
*** TODO Prepare a context in a temporary buffer that can be copy-pasted to the web UI.
*** TODO Automatically strip out context to fit within the limit.

** Backlog
*** TODO Include current price of project in the status bar.
*** TODO Allow selecting between different OpenAI models, while tracking the price, context length, etc.
*** TODO ChatGPT operator templates acting on code blocks
*** TODO Recursive ChatGPT templates


* Chat

** Project

Hello ChatGPT. Today we ware working on the first item in the todo list that I expect is in your context. Can you repeat it so I know you can see it?

** Run single test

How to run a single ERT test in emacs lisp?
** ChatGPT response                                               :assistant:
:PROPERTIES:
:input-tokens: 423
:output-tokens: 106
:billed-tokens: 529
:END:
To run a single ERT test in Emacs Lisp, you can use the `ert-run-tests-batch-and-exit` function and specify the test name as an argument.

Here's an example code snippet that runs a single ERT test named "my-test":

```
(require 'ert)

(ert-run-tests-batch-and-exit "my-test")
```

Replace "my-test" with the actual name of your test. You can also include a wildcard character `*` to run multiple tests with similar names.

*** And how about an interactive command to do it?
*** ChatGPT response                                              :assistant:
:PROPERTIES:
:input-tokens: 531
:output-tokens: 168
:billed-tokens: 699
:END:
(ChatGPT response)
You can create an interactive command that prompts the user for the test name and runs the ERT test using the `ert-run-tests-batch-and-exit` function. Here's an example code snippet that defines an interactive command named "run-single-ert-test":

```
(defun run-single-ert-test ()
  "Runs a single ERT test."
  (interactive)
  (let ((test-name (read-from-minibuffer "Enter ERT test name: ")))
    (ert-run-tests-batch-and-exit test-name)))
```

This command prompts the user for the test name using `read-from-minibuffer` and passes the input to `ert-run-tests-batch-and-exit`. You can bind this command to a keybinding or menu item to make it easier to use.

*** What about running the test at point?
*** ChatGPT response                                              :assistant:
:PROPERTIES:
:input-tokens: 706
:output-tokens: 241
:billed-tokens: 947
:END:
To run the test at point, you can use the `ert--select-test-at-point` function to get the name of the test and then call `ert-run-tests-batch-and-exit`. Here's an example code snippet that defines an interactive command named "run-ert-test-at-point":

```
(defun run-ert-test-at-point ()
  "Runs the ERT test at point."
  (interactive)
  (save-excursion
    (end-of-line)
    (let* ((bounds (bounds-of-thing-at-point 'symbol))
           (test-name (buffer-substring-no-properties (car bounds) (cdr bounds))))
      (ert-run-tests-batch-and-exit test-name))))
```

This command first moves the cursor to the end of the line containing the test definition using `end-of-line`. It then uses `bounds-of-thing-at-point` to get the boundaries of the symbol at point and `buffer-substring-no-properties` to extract the text of the symbol. Finally, it passes the test name to `ert-run-tests-batch-and-exit`. You can bind this command to a keybinding or menu item to make it easier to use.

*** Does that run the test whose name is the symbol at top-level after unnecesting all the parentheses?


*** ChatGPT response                                              :assistant:
:PROPERTIES:
:input-tokens: 1683
:output-tokens: 331
:billed-tokens: 2014
:END:
(ChatGPT response)
No, the `run-ert-test-at-point` function I provided assumes that the cursor is on the line containing the test definition. It extracts the test name from the symbol at point using `bounds-of-thing-at-point` and `buffer-substring-no-properties`, but it does not un-nest any parentheses.

If you want to run the test whose name is the symbol at top-level after un-nesting all the parentheses, you can modify the `run-ert-test-at-point` function to use a regular expression to search for the top-level test definition. Here's an example code snippet that accomplishes this:

```
(defun run-top-level-ert-test-at-point ()
  "Runs the top-level ERT test at point after un-nesting parentheses."
  (interactive)
  (save-excursion
    (re-search-backward "(ert-deftest \\([^ ()\t\n\r]*\\)")
    (let* ((test-name (match-string-no-properties 1))
           (real-test-name (cadr (split-string test-name "_"))))
      (ert-run-tests-batch-and-exit real-test-name))))
```

This command uses `re-search-backward` to search for the closest top-level test definition before the cursor position. It extracts the test name from the first group of the regular expression, then converts it to the "real" test name by removing the test prefix and any underscores. Finally, it passes the real test name to `ert-run-tests-batch-and-exit`. Note that this assumes that the test definitions follow the naming convention of `ert-deftest`.

*** I registered an interactive emacs function. How do I delete it?
*** ChatGPT response                                              :assistant:
:PROPERTIES:
:input-tokens: 1301
:output-tokens: 296
:billed-tokens: 1597
:END:
(ChatGPT response)
To unregister an interactive Emacs function, you can use the `global-unset-key` function to remove any keybinding associated with the function, then use the `fmakunbound` function to remove the function from the function table.

Here's an example code snippet:

```
(global-unset-key (kbd "C-c C-l")) ;; remove keybinding
(fmakunbound 'my-interactive-function) ;; remove function from function table
```

Replace "C-c C-l" with the keybinding associated with the function you want to remove, and "my-interactive-function" with the name of the function you want to remove.

Note that if the function is defined in a loaded library or package, the function may be reloaded the next time the package or library is loaded.

If you only want to temporarily disable the function without removing it, you can use `advice-add` to advise the function with a noop function that does nothing. When you want to re-enable the function, you can use `advice-remove` to remove the advice.

Here's an example code snippet that temporarily disables the `my-interactive-function` function:

```
(defun noop () nil) ;; define a noop function

(advice-add 'my-interactive-function :around #'noop) ;; advise the function with the noop function
```

To re-enable the function, use `(advice-remove 'my-interactive-function #'noop)`.


*** Testing

